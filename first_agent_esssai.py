from typing import Callable, Union, List, Tuple, Dict, Any
import subprocess
import re
import requests

class Tool:
    """A class representing a reusable piece of code (tool)."""

    def __init__(self,
                 name: str,
                 description: str,
                 func: Callable,
                 arguments: List[Tuple[str, str]],
                 outputs: Union[str, List[str]],
                 example_usage: str = ""):
        self.name = name
        self.description = description
        self.func = func
        self.arguments = arguments
        self.outputs = outputs
        self.example_usage = example_usage
    
    def to_string(self) -> str:
        """Returns a formatted string representation of the tool."""
        args_str = ', '.join([f"{args_name}: {args_type}" for args_name, args_type in self.arguments])
        return f"Tool: {self.name}\nDescription: {self.description}\nArguments: {args_str}\nReturns: {self.outputs}\nExample: {self.example_usage}"
    
    def __call__(self, *args, **kwargs):
        """Invokes the tool's function with the provided arguments."""
        return self.func(*args, **kwargs)


# Tool functions
def calculator_skono(a: int, b: int) -> int:
    """Fast integer calculation: a * b + 1"""
    return a * b + 1

def get_weather(city: str, api_key: str = "Your_api_key") -> dict:
    """Get current weather information for a city."""
    api_url = f"http://api.weatherapi.com/v1/current.json"
    params = {
        "key": api_key,
        "q": city,
        "aqi": "no"
    }

    try:
        response = requests.get(api_url, params=params, timeout=10)
        
        if response.status_code == 200:
            data = response.json()
            return {
                "location": data["location"]["name"],
                "region": data["location"]["region"], 
                "country": data["location"]["country"],
                "temperature_c": data["current"]["temp_c"],
                "temperature_f": data["current"]["temp_f"],
                "condition": data["current"]["condition"]["text"],
                "wind_kph": data["current"]["wind_kph"],
                "humidity": data["current"]["humidity"]
            }
        else:
            raise Exception(f"API request failed with status code {response.status_code}")
    except requests.RequestException as e:
        raise Exception(f"Network error: {str(e)}")


# Create tool instances
skono_tool = Tool(
    name="skono_calculator",
    description="Multiplies two integers and adds 1. Good for mathematical calculations.",
    func=calculator_skono,
    arguments=[("a", "int"), ("b", "int")],
    outputs="int",
    example_usage="skono_calculator(3, 4) returns 13"
)

weather_tool = Tool(
    name="get_weather",
    description="Gets current weather information for any city worldwide. Returns temperature, conditions, wind, and humidity.",
    func=get_weather,
    arguments=[("city", "str"), ("api_key", "str (optional)")],
    outputs="dict",
    example_usage='get_weather("London") returns weather data for London'
)


class ToolRegistry:
    """Manages multiple tools and handles tool selection."""
    
    def __init__(self):
        self.tools: Dict[str, Tool] = {}
        
    def register_tool(self, tool: Tool):
        """Register a new tool."""
        self.tools[tool.name] = tool
        
    def get_tools_description(self) -> str:
        """Get formatted description of all available tools."""
        if not self.tools:
            return "No tools available."
            
        descriptions = []
        for i, tool in enumerate(self.tools.values(), 1):
            descriptions.append(f"{i}. {tool.to_string()}")
            
        return "\n\n".join(descriptions)


class MistralClient:
    """Simple Mistral client for LLM interactions."""
    
    def __init__(self, model: str = "mistral"):
        self.model = model
    
    def call_mistral(self, prompt: str) -> str:
        """Call Mistral LLM with the given prompt."""
        try:
            process = subprocess.Popen(
                ["ollama", "run", self.model],
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                encoding='utf-8',
                errors='ignore'  # Ignore problematic characters
            )
            
            stdout, stderr = process.communicate(input=prompt, timeout=60)
            
            if process.returncode != 0:
                raise RuntimeError(f"Error calling model: {stderr}")
            return stdout.strip()
            
        except subprocess.TimeoutExpired:
            process.kill()
            raise RuntimeError("Model call timed out")


class CodeExecutor:
    """Executes code generated by the LLM."""
    
    def __init__(self, tool_registry: ToolRegistry):
        self.tool_registry = tool_registry
        
    def extract_and_execute_code(self, response: str) -> Any:
        """Extract and execute Python code from LLM response."""
        print(f"LLM Response: {response}")
        
        # Try to extract code block first
        code_match = re.search(r'```python\s*(.*?)\s*```', response, re.DOTALL)
        if code_match:
            code = code_match.group(1).strip()
        else:
            # Look for lines with function calls
            code_lines = []
            for line in response.split('\n'):
                line = line.strip()
                if any(tool_name in line for tool_name in self.tool_registry.tools.keys()):
                    if '(' in line:  # Looks like a function call
                        code_lines.append(line)
            
            if code_lines:
                code = '\n'.join(code_lines)
            else:
                raise ValueError("No executable code found in response")
        
        print(f"Extracted code: {code}")
        
        # Create safe execution environment with available tools
        safe_globals = {
            '__builtins__': {},
            **{name: tool.func for name, tool in self.tool_registry.tools.items()}
        }
        
        # Execute the code
        local_vars = {}
        try:
            exec(code, safe_globals, local_vars)
            
            # Try to find the result
            if 'result' in local_vars:
                return local_vars['result']
            else:
                # If no result variable, try to evaluate the expression
                lines = code.strip().split('\n')
                last_line = lines[-1].strip()
                if '=' in last_line:
                    var_name = last_line.split('=')[0].strip()
                    return local_vars.get(var_name)
                else:
                    # Direct function call
                    return eval(last_line, safe_globals)
                    
        except Exception as e:
            return f"Error executing code: {str(e)}"


class LLMAgent:
    """Main agent that uses Mistral LLM to select and execute tools."""
    
    def __init__(self):
        self.tool_registry = ToolRegistry()
        self.client = MistralClient()
        self.executor = CodeExecutor(self.tool_registry)
        
        # Register available tools
        self.tool_registry.register_tool(skono_tool)
        self.tool_registry.register_tool(weather_tool)
    
    def process_request(self, user_request: str) -> Any:
        """Process a user request using Mistral LLM to select and execute tools."""
        
        # Create system prompt with tool descriptions
        system_prompt = f"""You are a Python assistant with access to the following tools:

{self.tool_registry.get_tools_description()}

Instructions:
1. Analyze the user's request carefully
2. Choose the most appropriate tool based on what they're asking for
3. Return ONLY the Python code needed to call the chosen tool
4. Store the result in a variable called 'result'
5. Use proper function calls with correct parameters

Examples:
- For weather requests: result = get_weather("CityName")
- For calculations: result = skono_calculator(a, b)

User request: {user_request}

Return only the Python code, nothing else:"""

        print(f"User Request: {user_request}")
        print("Calling Mistral LLM...")
        
        # Get LLM response
        response = self.client.call_mistral(system_prompt)
        
        # Execute the generated code
        result = self.executor.extract_and_execute_code(response)
        return result


def main():
    """Demonstrate the LLM agent system."""
    
    # Create the agent
    agent = LLMAgent()
    
    # Test requests
    test_requests = [
        "What's the weather like in Paris?",
        "Calculate skono_calculator(5, 7)",
        "Get me the temperature in Tokyo",
        "I need to compute 3 * 4 + 1 using skono calculator",
        "How's the weather in New York today?",
        "Please calculate skono_calculator(10, 20)"
    ]
    
    print("=" * 60)
    print("LLM AGENT DEMO")
    print("=" * 60)
    
    for request in test_requests:
        print(f"\nüî∏ Processing: {request}")
        try:
            result = agent.process_request(request)
            print(f"üéØ Result: {result}")
        except Exception as e:
            print(f"‚ùå Error: {str(e)}")
        
        print("-" * 40)


if __name__ == "__main__":
    main()